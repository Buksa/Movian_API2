
# Документация UI-фреймворка

## Обзор

UI-фреймворк — это легковесная и гибкая система для создания графических пользовательских интерфейсов, разработанная для встраиваемых систем, мультимедийных приложений или специализированных платформ. Она предоставляет архитектуру на основе виджетов для создания динамичных и адаптивных макетов с поддержкой горизонтального, вертикального и z-слойного расположения. Фреймворк управляет ограничениями макета, рендерингом и обработкой событий, что делает его подходящим для приложений, требующих плавных анимаций и интерактивных элементов.

Фреймворк реализован на языке C для обеспечения производительности и переносимости, с высокоуровневым скриптовым интерфейсом для декларативного определения структуры интерфейса. Он поддерживает такие функции, как динамическое изменение размеров, взвешенные макеты, ограничения по соотношению сторон, анимации затухания и табличные макеты.

## Архитектура

Фреймворк построен на следующих основных концепциях:

-   **Виджеты**: Основные строительные блоки интерфейса, представляющие визуальные или интерактивные элементы (например, контейнеры, метки, кнопки).
-   **Контейнеры**: Специальные виджеты, управляющие расположением дочерних виджетов (например, `container_x`, `container_y`, `container_z`).
-   **Ограничения**: Правила, определяющие размер и позицию виджета, включая фиксированные размеры, веса и соотношения сторон.
-   **Контекст рендеринга**: Структура (`glw_rctx_t`), содержащая параметры рендеринга, такие как ширина, высота, прозрачность и преобразования.
-   **Сигналы**: События, вызывающие обновления (например, создание, удаление или изменение дочерних виджетов).

### Основные компоненты

-   **Класс виджета (**`glw_class_t`**)**: Определяет поведение типа виджета, включая макет, рендеринг и обработку сигналов.
-   **Экземпляр виджета (**`glw_t`**)**: Базовая структура для всех виджетов, содержащая свойства, такие как флаги, ограничения и связи родитель/дочерний.
-   **Контейнер (**`glw_container_t`**)**: Специализированный виджет для управления расположением дочерних элементов, с параметрами отступов, интервалов и режима макета.
-   **Таблица (**`glw_table_t`**)**: Виджет для табличных макетов, управляющий строками как контейнерами.
-   **Контекст рендеринга (**`glw_rctx_t`**)**: Управляет состоянием рендеринга, включая размеры, прозрачность, резкость и z-индекс.

## Типы виджетов

Фреймворк предоставляет несколько типов виджетов, из которых следующие являются ключевыми в предоставленном коде:

### 1. Горизонтальный контейнер (`container_x` / `hbox`)

-   **Назначение**: Располагает дочерние виджеты горизонтально (слева направо).
    
-   **Имя класса**: `container_x` (псевдоним: `hbox`).
    
-   **Основные возможности**:
    
    -   Поддерживает фиксированную ширину, взвешенное распределение и ограничения по соотношению сторон для дочерних элементов.
    -   Режим однородности (`GLW2_HOMOGENOUS`) обеспечивает одинаковую ширину всех дочерних элементов.
    -   Режим таблицы (`tableMode`) интегрируется с виджетами `table` для табличных макетов.
    -   Настраиваемые отступы и интервалы.
-   **Пример использования в скрипте**:
    
    ```plaintext
    widget(container_x, {
      padding: [2em, 0];
      spacing: $view.width / 30;
      cloner(propWindow($self.nodes, 0, 3), loader, {
        width: $view.width / 6;
        source: "skin://items/rect/" + $self.type + ".view";
      });
    });
    
    ```
    
-   **Реализация на C**:
    
    -   `glw_container_x_constraints`: Вычисляет общую ширину и максимальную высоту.
    -   `glw_container_x_layout`: Располагает дочерние элементы горизонтально, учитывая масштабирование и выравнивание.
    -   `glw_container_x_render`: Рендерит дочерние элементы с горизонтальными смещениями и масштабированием.

### 2. Вертикальный контейнер (`container_y` / `vbox`)

-   **Назначение**: Располагает дочерние виджеты вертикально (сверху вниз).
    
-   **Имя класса**: `container_y` (псевдоним: `vbox`).
    
-   **Основные возможности**:
    
    -   Поддерживает фиксированную высоту, взвешенное распределение и ограничения по соотношению сторон.
    -   Анимации затухания (`GLW2_AUTOFADE`) для плавного изменения видимости дочерних элементов.
    -   Настраиваемые отступы и интервалы.
-   **Пример использования в скрипте**:
    
    ```plaintext
    widget(list_y, {
      id: "scrollable";
      clipOffsetTop: 3em;
      scrollThresholdTop: 5em;
      spacing: 1em;
      cloner($self.model.nodes, container_y, {
        widget(label, {
          padding: [1em, 0];
          caption: fmt('%s <font size="2" color="#aaaaaa">- %s', ...);
        });
      });
    });
    
    ```
    
-   **Реализация на C**:
    
    -   `glw_container_y_constraints`: Вычисляет общую высоту и максимальную ширину.
    -   `glw_container_y_layout`: Располагает дочерние элементы вертикально, поддерживая анимации затухания.
    -   `glw_container_y_render`: Рендерит дочерние элементы с вертикальными смещениями и эффектами затухания.

### 3. Z-слойный контейнер (`container_z` / `zbox`)

-   **Назначение**: Накладывает дочерние виджеты друг на друга по оси z (слои).
    
-   **Имя класса**: `container_z` (псевдоним: `zbox`).
    
-   **Основные возможности**:
    
    -   Копирует ограничения от первого видимого дочернего элемента с ограничениями.
    -   Рендерит дочерние элементы в порядке z-индекса.
-   **Пример использования в скрипте**:
    
    ```plaintext
    widget(container_z, {
      widget(list_y, { ... });
      widget(container_y, {
        align: top;
        PageHeader($self.model.metadata.title);
      });
    });
    
    ```
    
-   **Реализация на C**:
    
    -   `glw_container_z_constraints`: Копирует ограничения от дочернего элемента.
    -   `glw_container_z_layout`: Располагает дочерние элементы в одной позиции.
    -   `glw_container_z_render`: Рендерит дочерние элементы с увеличивающимся z-индексом.

### 4. Таблица (`table`)

-   **Назначение**: Управляет табличным макетом, где строки представлены контейнерами.
-   **Имя класса**: `table`.
-   **Основные возможности**:
    -   Динамически вычисляет ширину столбцов на основе строк-контейнеров.
    -   Интегрируется с `container_x` в режиме `tableMode`.
-   **Пример использования в скрипте**: Не используется напрямую в предоставленном скрипте, но упоминается через `tableMode`.
-   **Реализация на C**:
    -   `table_recompute`: Вычисляет ширину столбцов и общую ширину.
    -   `glw_table_callback`: Обрабатывает изменения ограничений строк.

## Основные функции

### Система ограничений

Виджеты определяют свои требования к размерам с помощью ограничений:

-   **Фиксированный размер** (`GLW_CONSTRAINT_X`, `GLW_CONSTRAINT_Y`): Явная ширина или высота (например, `glw_req_width`, `glw_req_height`).
-   **Вес** (`GLW_CONSTRAINT_W` с `glw_req_weight > 0`): Пропорциональное распределение оставшегося пространства.
-   **Соотношение сторон** (`GLW_CONSTRAINT_W` с `glw_req_weight < 0`): Ширина или высота зависят от другой размерности (например, `width = height * -weight`).

Контейнеры вычисляют свои размеры, агрегируя ограничения дочерних элементов, учитывая отступы и интервалы.

### Макет

Каждый тип контейнера имеет функцию макета, которая позиционирует дочерние элементы:

-   **Горизонтальный**: Распределяет ширину между дочерними элементами, учитывая фиксированные размеры, веса и соотношения сторон.
-   **Вертикальный**: Распределяет высоту, с опциональными анимациями затухания для изменения видимости.
-   **Z-слойный**: Накладывает дочерние элементы друг на друга, используя z-индекс для определения порядка рендеринга.

### Рендеринг

Рендеринг применяет преобразования (позиция, масштаб, прозрачность) к каждому дочернему элементу:

-   **Прозрачность**: Комбинирует прозрачность виджета и контекста рендеринга (`rc_alpha * w->glw_alpha`).
-   **Резкость**: Влияет на визуальную четкость (`rc_sharpness * w->glw_sharpness`).
-   **Преобразования**: Использует `glw_Translatef` и `glw_Scalef` для позиционирования и масштабирования.

### Обработка событий

Фреймворк использует систему сигналов для обработки событий:

-   **События дочерних элементов**: `GLW_SIGNAL_CHILD_CONSTRAINTS_CHANGED`, `GLW_SIGNAL_CHILD_CREATED`, `GLW_SIGNAL_CHILD_DESTROYED` и др. вызывают пересчет ограничений.
-   **Навигация**: `glw_navigate_horizontal` и `glw_navigate_vertical` управляют перемещением фокуса.
-   **Удаление**: Освобождает ресурсы (например, массивы ширин столбцов).

## Скриптовый интерфейс

Фреймворк включает высокоуровневый скриптовый язык для декларативного определения макетов интерфейса. Скрипт использует синтаксис, похожий на JSON или специализированный язык, с следующими возможностями:

-   **Объявление виджета**: `widget(type, { properties })` создает виджет указанного типа.
-   **Свойства**: Пары ключ-значение для настройки виджетов (например, `padding`, `spacing`, `caption`).
-   **Клонеры**: `cloner(data, container, { ... })` генерирует несколько виджетов из источника данных.
-   **Обработчики событий**: `onEvent(event, action)` привязывает действия к событиям (например, `onEvent(activate, navOpen($self.url))`).

### Пример скрипта

```plaintext
widget(container_z, {
  widget(list_y, {
    id: "scrollable";
    clipOffsetTop: 3em;
    scrollThresholdTop: 5em;
    spacing: 1em;
    cloner($self.model.nodes, container_y, {
      widget(label, {
        padding: [1em, 0];
        caption: fmt('%s <font size="2" color="#aaaaaa">- %s', ...);
      });
      widget(container_x, {
        padding: [2em, 0];
        spacing: $view.width / 30;
        cloner(propWindow($self.nodes, 0, 3), loader, {
          width: $view.width / 6;
          source: "skin://items/rect/" + $self.type + ".view";
        });
      });
    });
  });
  widget(container_y, {
    align: top;
    PageHeader($self.model.metadata.title);
  });
});

```

Этот скрипт создает прокручиваемый список с заголовком, где каждый элемент списка содержит метку и горизонтальную сетку из до трех элементов.

## Руководство по использованию

### Создание виджета

1.  **Определите тип виджета**: Используйте зарегистрированный класс (например, `container_x`, `container_y`).
2.  **Установите свойства**:
    -   `padding: [left, top, right, bottom]` (например, `[1em, 0, 1em, 0]`).
    -   `spacing: value` (например, `1em` для интервала между дочерними элементами).
    -   `align: position` (например, `top`, `center`, `bottom` для `container_y`).
3.  **Добавьте дочерние элементы**: Вложите вызовы `widget` или используйте `cloner` для динамических списков.
4.  **Обработайте события**: Используйте `focusable: true` и `onEvent` для интерактивности.

### Настройка макета

-   **Фиксированные размеры**: Укажите явные ширину или высоту в дочерних виджетах.
-   **Взвешенный макет**: Используйте `weight` для распределения оставшегося пространства (например, `glw_req_weight = 1.0`).
-   **Соотношения сторон**: Установите отрицательные веса для дочерних элементов с ограничением по соотношению сторон (например, `glw_req_weight = -2.0` для `width = 2 * height`).
-   **Режим однородности**: Включите `GLW2_HOMOGENOUS` для одинаковых размеров дочерних элементов в `container_x`.

### Рендеринг и анимации

-   **Анимации затухания**: Включите `GLW2_AUTOFADE` в `container_y` для плавного изменения видимости дочерних элементов.
-   **Обрезка**: Используйте свойства, такие как `clipOffsetTop`, `clipAlpha` и `clipBlur` (обрабатываются высокоуровневым кодом фреймворка).
-   **Пользовательские стили**: Применяйте стили, такие как `GridItemBevel()` или `GridItemHighlight()`, для визуальных эффектов.

### Табличные макеты

-   Включите `tableMode: true` в `container_x` для интеграции с виджетом `table`.
-   Определите строки как контейнеры, каждый из которых задает ширину столбцов.

### Отладка с использованием GLW2_DEBUG

Флаг `GLW2_DEBUG` — это инструмент для отладки, который активирует вывод диагностической информации о вычислении ограничений и макета виджетов. Он включается в поле `glw_flags2` структуры `glw_t` для конкретного виджета, чтобы логировать подробности в консоль.

#### Функциональность GLW2_DEBUG

-   **Ограничения**:
    -   Выводит начало цикла вычисления ограничений (`"Constraint round\n"`).
    -   Для каждого дочернего элемента показывает флаги ограничений (`X`, `Y`, `W`), запрошенные ширину, высоту и вес (например, `printf("%c%c%c %d %d %f\n", ...)`).
    -   Выводит итоговые размеры контейнера и флаги ограничений (например, `printf("Total dimensions: %d x %d 0x%x\n", width, height, cflags)`).
-   **Макет**:
    -   Логирует размеры контейнера и режим таблицы (например, `printf("%d x %d tablemode:%s\n", rc->rc_width, rc->rc_height, tab ? "yes" : "no")`).
    -   Выводит суммы ширин, включая ширину от ограничений, аспекта и интервалов.
    -   Для каждого дочернего элемента показывает выделенную ширину и интервал.

#### Применение

-   **Диагностика макета**: Помогает выявить причины неправильных размеров или позиций (например, нулевая ширина дочернего элемента).
-   **Отладка ограничений**: Показывает, какие ограничения применяются и как они влияют на контейнер.
-   **Проверка выравнивания**: Позволяет анализировать позиции дочерних элементов в зависимости от выравнивания (`LAYOUT_ALIGN_LEFT`, `LAYOUT_ALIGN_CENTER`).
-   **Разработка**: Используется для проверки корректности скриптов (например, значений `padding` или `spacing`).

#### Пример вывода

Для `container_x` с тремя дочерними элементами (два с фиксированной шириной 100 и 200, один с весом 1.0):

```
Constraint round
X Y   100  50  0.0
X     200  0   0.0
      0    0   1.0
Total width: 300
800 x 600 tablemode:no
Widthsum: xconstraints:300 aspect:0 spacing:20
    child get 100 spacing:10
    child get 200 spacing:10
    child get 470 spacing:10

```

#### Включение

Установите флаг в C-коде:

```c
widget->glw_flags2 |= GLW2_DEBUG;

```

В скрипте это может быть свойство (гипотетически):

```plaintext
widget(container_x, {
  debug: true;
  ...
});

```

#### Рекомендации

-   **Производительность**: Отключайте `GLW2_DEBUG` в продакшене, так как он увеличивает объем вывода в консоль.
-   **Читаемость**: Включайте только для проблемных виджетов, чтобы избежать перегрузки логов.
-   **Комбинирование**: Используйте с другими методами отладки, например, логированием событий или визуальной инспекцией.

## Справочник API

### Основные структуры

-   `glw_t`:
    -   `glw_flags`: Флаги видимости и состояния (например, `GLW_HIDDEN`, `GLW_RETIRED`).
    -   `glw_flags2`: Дополнительные флаги (например, `GLW2_DEBUG`, `GLW2_HOMOGENOUS`, `GLW2_AUTOFADE`).
    -   `glw_alpha`: Прозрачность виджета.
    -   `glw_sharpness`: Фактор визуальной четкости.
    -   `glw_childs`: Очередь дочерних виджетов.
-   `glw_container_t`:
    -   `co_padding[4]`: Отступы для левой, верхней, правой и нижней сторон.
    -   `co_spacing`: Интервал между дочерними элементами.
    -   `co_num_columns`: Количество столбцов (в режиме таблицы).
    -   `co_table`: Родительская таблица (если в режиме таблицы).
-   `glw_table_t`:
    -   `gt_columns`: Массив ширин столбцов.
    -   `gt_num_columns`: Количество столбцов.
    -   `gt_rows`: Связный список строк-контейнеров.

### Ключевые функции

-   `glw_set_constraints(w, width, height, weight, flags)`: Устанавливает ограничения виджета.
-   `glw_layout0(w, rc)`: Выполняет макет виджета в заданном контексте рендеринга.
-   `glw_render0(w, rc)`: Рендерит виджет.
-   `glw_need_refresh(root, 0)`: Отмечает интерфейс для обновления.
-   `glw_signal0(w, signal, extra)`: Отправляет сигнал виджету.

### Сигналы

-   `GLW_SIGNAL_CHILD_CONSTRAINTS_CHANGED`: Изменены ограничения дочернего элемента.
-   `GLW_SIGNAL_CHILD_CREATED`: Добавлен новый дочерний элемент.
-   `GLW_SIGNAL_CHILD_DESTROYED`: Удален дочерний элемент.
-   `GLW_SIGNAL_CHILD_HIDDEN` / `GLW_SIGNAL_CHILD_UNHIDDEN`: Изменена видимость дочернего элемента.
-   `GLW_SIGNAL_DESTROY`: Виджет уничтожен.

## Рекомендации

-   **Оптимизируйте ограничения**: Минимизируйте использование фиксированных размеров для создания гибких макетов.
-   **Используйте клонеры для списков**: Применяйте `cloner` для динамического контента, чтобы упростить скрипты.
-   **Ограничивайте анимации**: Включайте `GLW2_AUTOFADE` только при необходимости, чтобы избежать снижения производительности.
-   **Отладка**: Включайте `GLW2_DEBUG` для диагностики макета, но отключайте в продакшене.
-   **Модульность скриптов**: Разбивайте сложные интерфейсы на переиспользуемые определения виджетов.

## Ограничения

-   **Отсутствие встроенной обрезки**: Свойства, такие как `clipAlpha`, требуют дополнительного кода фреймворка.
-   **Ограниченные ограничения z-слоя**: `container_z` зависит от ограничений дочерних элементов, что может ограничивать гибкость.
-   **Сложность режима таблицы**: Требует тщательного управления ограничениями строк и столбцов.

## Пример приложения

Для создания интерфейса медиа-галереи:

1.  Используйте `container_z` как корневой контейнер.
2.  Добавьте `list_y` для прокручиваемого списка категорий.
3.  Для каждой категории используйте `container_y` с `label` (заголовок) и `container_x` (сетка элементов).
4.  Используйте `cloner` для заполнения сетки элементами из источника данных.
5.  Добавьте `focusable` кнопку "Показать больше" для перехода к дополнительному контенту.

Эта структура реализована в предоставленном коде виджетов, который создает прокручиваемый список с сеточными строками и интерактивными элементами.

## Заключение

UI-фреймворк предоставляет надежную основу для создания динамичных и интерактивных пользовательских интерфейсов. Его архитектура на основе виджетов, система ограничений и скриптовый интерфейс позволяют разработчикам создавать адаптивные макеты с минимальным количеством кода. Используя контейнеры, таблицы, анимации и инструменты отладки, такие как `GLW2_DEBUG`, разработчики могут создавать сложные интерфейсы для различных приложений.

Для получения дополнительной информации обратитесь к исходному коду или свяжитесь с разработчиками фреймворка по адресу [andreas@lonelycoder.com](mailto:andreas@lonelycoder.com).
